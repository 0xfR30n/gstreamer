/* -*- Mode: C; c-basic-offset: 4 -*- */
/* gst-python
 * Copyright (C) 2004 Johan Dahlin
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 * 
 * Author: Johan Dahlin <johan@gnome.org
 */
%%
headers

/* we need to do this until PyClosures get exception handlers */
#ifndef pyg_closure_set_exception_handler
#  define pyg_closure_set_exception_handler(ig, nore)
#  define EXCEPTION_HANDLER G_GNUC_UNUSED
#else
#  define EXCEPTION_HANDLER
#endif
#define SET_PAD_CLOSURE(self, args, kwargs, name) \
	static char *kwlist[] = { G_STRINGIFY (name), NULL }; \
	PyObject *function; \
	GstPad *pad; \
	GClosure *closure; \
	PyGstPadPrivate *priv; \
\
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, \
					 "O:GstPad.set_" G_STRINGIFY (name), \
					 kwlist, \
					 &function)) { \
		return NULL; \
	} \
\
	if (!PyCallable_Check(function)) { \
		PyErr_SetString(PyExc_TypeError, G_STRINGIFY (name) " not callable"); \
		return NULL; \
	} \
\
	closure = pyg_closure_new (function, NULL, NULL); \
	pyg_closure_set_exception_handler (closure, handle_ ## name ## _exception); \
	pygobject_watch_closure((PyObject *)self, closure); \
	priv = py_pad_private(self);\
	if (priv->name) { \
	  g_closure_invalidate (priv->name); \
	  g_closure_unref (priv->name); \
	} \
	priv->name = closure; \
	pad = (GstPad*)pygobject_get(self); \
	gst_pad_set_ ## name (pad, call_ ## name); \
\
	Py_INCREF(Py_None); \
	return Py_None;
	
static void
free_pad_private (gpointer data)
{
  PyGstPadPrivate *private = data;
#define INVALIDATE_CLOSURE(closure) \
  if (closure) { \
    g_closure_invalidate (closure); \
    g_closure_unref (closure); \
    closure = NULL; \
  } 
  INVALIDATE_CLOSURE (private->link_function)
  INVALIDATE_CLOSURE (private->event_function)
  INVALIDATE_CLOSURE (private->chain_function)
  INVALIDATE_CLOSURE (private->get_function)
  INVALIDATE_CLOSURE (private->getcaps_function)
#undef INVALIDATE_CLOSURE
}

static PyGstPadPrivate*
pad_private(GstPad *pad)
{
	PyGstPadPrivate *private;
	static GQuark padprivate = 0;

	if (!padprivate)
		padprivate = g_quark_from_static_string ("PyGst::PadPrivate");
	private = g_object_get_qdata (G_OBJECT (pad), padprivate);
	if (private == NULL) {
		private = g_new0(PyGstPadPrivate, 1);
		private->pad = (PyGObject *) pygobject_new (G_OBJECT (pad));
		Py_DECREF (private->pad);
		g_object_set_qdata_full (G_OBJECT (pad), padprivate, private, free_pad_private);
	}
	return private;
}
	
static PyGstPadPrivate*
py_pad_private(PyGObject *pad)
{
	return pad_private ((GstPad *)pygobject_get(pad));
}

%%
ignore
  gst_pad_select
  gst_pad_selectv
  gst_pad_new_from_template
  gst_pad_load_and_link
%%
override gst_pad_set_getcaps_function kwargs

static void EXCEPTION_HANDLER
handle_getcaps_function_exception (GValue *ret, guint n, const GValue *params)
{
  g_value_set_boxed (ret, gst_pad_get_pad_template_caps (
      GST_PAD (g_value_get_object (&params[0]))));
  PyErr_Clear ();
}

static GstCaps *
call_getcaps_function (GstPad *pad)
{
	GClosure *closure;
	GValue ret = { 0, };
	GValue args = { 0, };
	GstCaps *caps;
	
	g_value_init (&ret, GST_TYPE_CAPS);
	g_value_init (&args, GST_TYPE_REAL_PAD);
	g_value_set_object (&args, pad);
	
	closure = pad_private(pad)->getcaps_function;
	
	g_closure_invoke (closure, &ret, 1, &args, NULL);

	caps = g_value_dup_boxed (&ret);
	g_value_unset (&ret);
	g_value_unset (&args);
	return caps;
}

static PyObject*
_wrap_gst_pad_set_getcaps_function (PyGObject *self,
		PyObject  *args,
		PyObject  *kwargs)
{
	SET_PAD_CLOSURE (self, args, kwargs, getcaps_function)
}

%%
override gst_pad_set_link_function kwargs

static void EXCEPTION_HANDLER
handle_link_function_exception (GValue *ret, guint n, const GValue *params)
{
  g_value_set_enum (ret, GST_PAD_LINK_REFUSED);
  PyErr_Clear ();
}

static GstPadLinkReturn
call_link_function (GstPad *pad, const GstCaps *caps)
{
	GClosure *closure;
	GValue ret = { 0, };
	GValue args[2] = { { 0, }, {0, } };
	GstPadLinkReturn i;
	
	g_value_init (&ret, GST_TYPE_PAD_LINK_RETURN);
	g_value_init (&args[0], GST_TYPE_REAL_PAD);
	g_value_init (&args[1], GST_TYPE_CAPS);
	g_value_set_object (&args[0], pad);
	g_value_set_boxed (&args[1], caps);
	
	closure = pad_private(pad)->link_function;
	
	g_closure_invoke (closure, &ret, 2, args, NULL);

	i = g_value_get_enum (&ret);
	g_value_unset (&ret);
	g_value_unset (&args[0]);
	g_value_unset (&args[1]);
	return i;
}

static PyObject*
_wrap_gst_pad_set_link_function (PyGObject *self,
		PyObject  *args,
		PyObject  *kwargs)
{
	SET_PAD_CLOSURE (self, args, kwargs, link_function)
}

%%
override gst_pad_set_chain_function kwargs

static void EXCEPTION_HANDLER
handle_chain_function_exception (GValue *ret, guint n, const GValue *params)
{
  GstElement *element = gst_pad_get_parent (g_value_get_object (&params[0]));
  
  if (!_pygst_element_check_error (element))
    g_assert_not_reached (); /* only returns FALSE when there's no error */
}

static void
call_chain_function(GstPad *pad, GstData *data)
{
	GClosure *closure;
	GValue args[2] = { { 0, }, { 0, } };
	
	g_value_init (&args[0], GST_TYPE_REAL_PAD);
	if (GST_IS_BUFFER (data)) {
	  g_value_init (&args[1], GST_TYPE_BUFFER);
	} else if (GST_IS_EVENT (data)) {
	  g_value_init (&args[1], GST_TYPE_EVENT);
	} else {
	  g_value_init (&args[1], GST_TYPE_DATA);
	}
	g_value_set_object (&args[0], pad);
	g_value_take_boxed (&args[1], data);
	closure = pad_private(pad)->chain_function;
	
	g_closure_invoke (closure, NULL, 2, args, NULL);

	g_value_unset (&args[0]);
	g_value_unset (&args[1]);
}

static PyObject*
_wrap_gst_pad_set_chain_function(PyGObject *self,
				PyObject  *args,
				PyObject  *kwargs)
{
	SET_PAD_CLOSURE (self, args, kwargs, chain_function)
}
%%
override gst_pad_set_event_function kwargs

static void EXCEPTION_HANDLER
handle_event_function_exception (GValue *ret, guint n, const GValue *params)
{
  GstElement *element = gst_pad_get_parent (g_value_get_object (&params[0]));
  
  if (!_pygst_element_check_error (element))
    g_assert_not_reached (); /* only returns FALSE when there's no error */
}

static gboolean
call_event_function (GstPad *pad, GstEvent *event)
{
	GClosure *closure;
	GValue ret = { 0, };
	GValue args[2] = { { 0, }, { 0, } };
	gboolean bool;
	
	g_value_init (&ret, G_TYPE_BOOLEAN);
	g_value_set_boolean (&ret, FALSE);
	g_value_init (&args[0], GST_TYPE_REAL_PAD);
	g_value_init (&args[1], GST_TYPE_EVENT);
	g_value_set_object (&args[0], pad);
	g_value_set_boxed (&args[1], event);
	closure = pad_private(pad)->event_function;
	
	g_closure_invoke (closure, &ret, 2, args, NULL);

	bool = g_value_get_boolean (&ret);

	g_value_unset (&ret);
	g_value_unset (&args[0]);
	g_value_unset (&args[1]);
	return bool;
}

static PyObject*
_wrap_gst_pad_set_event_function (PyGObject *self,
				  PyObject  *args,
				  PyObject  *kwargs)
{
	SET_PAD_CLOSURE (self, args, kwargs, event_function)
}

%%
override gst_pad_set_get_function kwargs

static void EXCEPTION_HANDLER
handle_get_function_exception (GValue *ret, guint n, const GValue *params)
{
  GstElement *element = gst_pad_get_parent (g_value_get_object (&params[0]));
  
  if (!_pygst_element_check_error (element))
    g_assert_not_reached (); /* only returns FALSE when there's no error */
}

static GstData*
call_get_function (GstPad *pad)
{
	GClosure *closure;
	GValue ret = { 0, };
	GValue args = { 0, };
	GstData *data = NULL;
	
	g_value_init (&ret, GST_TYPE_DATA);
	g_value_init (&args, GST_TYPE_REAL_PAD);
	g_value_set_object (&args, pad);
	closure = pad_private(pad)->get_function;
	
	g_closure_invoke (closure, &ret, 1, &args, NULL);

	data = g_value_get_boxed (&ret);
	gst_data_ref (data);

	g_value_unset (&ret);
	g_value_unset (&args);
	return data;
}

static PyObject*
_wrap_gst_pad_set_get_function (PyGObject *self,
				PyObject  *args,
				PyObject  *kwargs)
{
	SET_PAD_CLOSURE (self, args, kwargs, get_function)
}
%%
override-slot GstPad.tp_repr
static PyObject *
_wrap_gst_pad_tp_repr (PyGObject *self)
{
	char *buf;
	PyObject *retval;
  	GstPad *pad;
  	GstElement *parent;

	pad = GST_PAD(self->obj);
	parent = gst_pad_get_parent (pad);
	    
	buf = g_strdup_printf ("<GstPad (%s:%s) at %lx>",
		parent ? gst_element_get_name (parent) : "---",
		gst_pad_get_name (pad), (long) self->obj);

	retval = PyString_FromString(buf);
	g_free(buf);
	return retval;
}

%%
override gst_pad_query kwargs
static PyObject *
_wrap_gst_pad_query(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "type", "format", NULL };
	GstQueryType type;
	GstFormat format;
	gint64 value = 0;
	gboolean ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "ii:GstPad.query", kwlist,
					 &type, &format))
		return NULL;
	
	ret = gst_pad_query(GST_PAD(self->obj), type, &format, &value);
	return PyLong_FromLongLong(value);
}
%%
override gst_pad_convert kwargs
static PyObject *
_wrap_gst_pad_convert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "src_format", "src_value",
				  "dest_format", NULL };
	GstFormat src_format, dest_format;
	PyObject *src_value_obj;
	gint64 src_value, dest_value = 0;
	gboolean ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "iOi:GstPad.convert", kwlist,
					 &src_format, &src_value_obj,
					 &dest_format))
		return NULL;
	
	src_value = PyLong_AsLongLong(src_value_obj);
	
	ret = gst_pad_convert(GST_PAD(self->obj), src_format, src_value,
			      &dest_format, &dest_value);
	return PyLong_FromLongLong(dest_value);
}
%%
override gst_pad_link kwargs
static PyObject *
_wrap_gst_pad_link(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "sinkpad", NULL };
    PyGObject *sinkpad;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GstPad.link", kwlist,
                                     &PyGstPad_Type, &sinkpad))
        return NULL;
    ret = gst_pad_link(GST_PAD(self->obj), GST_PAD(sinkpad->obj));
    if (!ret) {
        PyErr_SetString(PyGstExc_LinkError, "link failed");
        return NULL;
    }
    return PyBool_FromLong(ret);
}

%%
override gst_pad_link_filtered kwargs
static PyObject *
_wrap_gst_pad_link_filtered(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "sinkpad", "filtercaps", NULL };
    PyGObject *sinkpad;
    PyObject *py_filtercaps;
    int ret;
    GstCaps *filtercaps = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!O:GstPad.link_filtered",
                                     kwlist, &PyGstPad_Type, &sinkpad,
                                     &py_filtercaps))
        return NULL;
    if (pyg_boxed_check(py_filtercaps, GST_TYPE_CAPS))
        filtercaps = pyg_boxed_get(py_filtercaps, GstCaps);
    else {
        PyErr_SetString(PyExc_TypeError, "filtercaps should be a GstCaps");
        return NULL;
    }
    ret = gst_pad_link_filtered(GST_PAD(self->obj),
                                GST_PAD(sinkpad->obj),
                                filtercaps);
    if (!ret) {
        PyErr_SetString(PyGstExc_LinkError, "link failed");
        return NULL;
    }
    return PyBool_FromLong(ret);
}

%%
override gst_pad_get_negotiated_caps
static PyObject *
_wrap_gst_pad_get_negotiated_caps(PyGObject *self)
{
	const GstCaps *ret;

	ret = gst_pad_get_negotiated_caps(GST_PAD(self->obj));
	/* pyg_boxed_new handles NULL checking */
	return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
override gst_pad_get_negotiated_caps noargs
static PyObject *
_wrap_gst_pad_get_negotiated_caps(PyGObject *self)
{
	GstCaps *ret = (GstCaps*)gst_pad_get_negotiated_caps(GST_PAD(self->obj));
	return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
override gst_pad_get_pad_template_caps noargs
static PyObject *
_wrap_gst_pad_get_pad_template_caps(PyGObject *self)
{
	GstCaps *ret = (GstCaps*)gst_pad_get_pad_template_caps(GST_PAD(self->obj));
	return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
override gst_pad_template_get_caps noargs
static PyObject *
_wrap_gst_pad_template_get_caps(PyGObject *self)
{
	GstCaps *ret = (GstCaps*)gst_pad_template_get_caps(GST_PAD_TEMPLATE(self->obj));
	return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
override gst_pad_template_get_caps_by_name kwargs
static PyObject *
_wrap_gst_pad_template_get_caps_by_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;
    GstCaps *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s:GstPadTemplate.get_caps_by_name", kwlist, &name))
        return NULL;
    ret = (GstCaps*)gst_pad_template_get_caps_by_name(GST_PAD_TEMPLATE(self->obj), name);
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
override gst_pad_new kwargs
static int
_wrap_gst_pad_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", "direction", NULL };
    static char *kwlist2[] = { "template", "name", NULL };
    PyGObject *templ;
    char *name = NULL;
    PyObject *py_direction = NULL;
    GstPadDirection direction;

    if (PyArg_ParseTupleAndKeywords(args, kwargs, "sO:GstPad.__init__", kwlist, &name, &py_direction)) {
      if (pyg_enum_get_value(GST_TYPE_PAD_DIRECTION, py_direction, (gint *)&direction))
	  return -1;
      self->obj = (GObject *)gst_pad_new(name, direction);
    } else {
      PyErr_Clear ();
      if (PyArg_ParseTupleAndKeywords(args, kwargs, "O!|s:GstPad.__init__", kwlist2, &PyGstPadTemplate_Type, &templ, &name)) {
	if (name == NULL) 
	  name = GST_PAD_TEMPLATE_NAME_TEMPLATE (GST_PAD_TEMPLATE(templ->obj));
	self->obj = (GObject *)gst_pad_new_from_template(GST_PAD_TEMPLATE(templ->obj), name);
      }
    }
    if (!self->obj) {
      PyErr_SetString(PyExc_RuntimeError, "could not create GstPad object");
      return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override-slot GstPadTemplate.tp_getattr
#define IS_ATTR(name) (strcmp (name, attr) == 0)
PyObject *
_wrap_gst_pad_template_tp_getattr(PyObject *self, char *attr)
{
  GstPadTemplate *templ = GST_PAD_TEMPLATE (pygobject_get (self));
  
  if (IS_ATTR ("__members__")) {
    return Py_BuildValue("[ssss]", "name_template", "direction", "presence", "caps" );
  } else if (IS_ATTR ("name_template")) {
    return PyString_FromString (GST_PAD_TEMPLATE_NAME_TEMPLATE(templ));
  } else if (IS_ATTR ("direction")) {
    return pyg_enum_from_gtype(GST_TYPE_PAD_DIRECTION, GST_PAD_TEMPLATE_DIRECTION(templ));
  } else if (IS_ATTR ("presence")) {
    return pyg_enum_from_gtype(GST_TYPE_PAD_PRESENCE, GST_PAD_TEMPLATE_PRESENCE(templ));
  } else if (IS_ATTR ("caps")) {
    return pyg_boxed_new (GST_TYPE_CAPS, GST_PAD_TEMPLATE_CAPS(templ), TRUE, TRUE);
  }
  return Py_FindMethod(_PyGstPadTemplate_methods, self, attr);
}

