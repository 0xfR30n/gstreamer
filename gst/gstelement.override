/* -*- Mode: C; c-basic-offset: 4 -*- */
/* gst-python
 * Copyright (C) 2005 Johan Dahlin
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 * 
 * Author: Johan Dahlin <johan@gnome.org>
 */
%%
ignore
  gst_element_get
  gst_element_set
  gst_element_get_property
  gst_element_set_property
%%
override gst_element_get_pad_list noargs
static PyObject *
_wrap_gst_element_get_pad_list(PyGObject *self)
{
	GList *l, *pads;
	PyObject *list;
	
	pads = GST_ELEMENT_PADS(GST_ELEMENT(self->obj));

	list = PyList_New(0);
	for (l = pads; l; l = l->next) {
		GstPad *pad = (GstPad*)l->data;
		PyList_Append(list, pygobject_new(G_OBJECT(pad)));
	}
		
	return list;
}
%%
override gst_element_get_pad_template_list noargs
static PyObject *
_wrap_gst_element_get_pad_template_list(PyGObject *self)
{
	GList *l, *pads;
	PyObject *list;
	
	pads = (GList*)gst_element_get_pad_template_list(GST_ELEMENT(self->obj));

	list = PyList_New(0);
	for (l = pads; l; l = l->next) {
		GstPad *pad = (GstPad*)l->data;
		PyList_Append(list, pygobject_new(G_OBJECT(pad)));
	}
		
	return list;
}
%%
override gst_element_set_state kwargs
static PyObject *
_wrap_gst_element_set_state(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "state", NULL };
	PyObject *py_state = NULL;
	GstElementState state;
	gint ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GstElement.set_state", kwlist, &py_state))
		return NULL;
	if (pyg_flags_get_value(GST_TYPE_ELEMENT_STATE, py_state, (gint *)&state))
		return NULL;

	pyg_begin_allow_threads;
    
	ret = gst_element_set_state(GST_ELEMENT(self->obj), state);
    
	pyg_end_allow_threads;

	return PyInt_FromLong(ret);
}
%%
override gst_element_query kwargs
static PyObject *
_wrap_gst_element_query(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "type", "format", NULL };
	GstQueryType type;
	GstFormat format;
	gint64 value = 0;
	gboolean ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "ii:GstElement.query", kwlist,
					 &type, &format))
		return NULL;
	
	ret = gst_element_query(GST_ELEMENT(self->obj), type, &format, &value);
	return PyLong_FromLongLong(value);
}
%%
override gst_element_convert kwargs
static PyObject *
_wrap_gst_element_convert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "src_format", "src_value", "dest_format", NULL };
	GstFormat src_format, dest_format;
	PyObject *src_value_obj;
	gint64 src_value, dest_value;
	gboolean ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iOi:GstElement.convert", kwlist, &src_format, &src_value_obj, &dest_format))
		return NULL;
	src_value = PyLong_AsLongLong(src_value_obj);
	dest_value = 0;
	ret = gst_element_convert(GST_ELEMENT(self->obj), src_format, src_value, &dest_format, &dest_value);
	if (!ret) {
		PyErr_SetString(PyExc_RuntimeError, "conversion could not be performed");
		return NULL;
	}
	
	return PyInt_FromLong(dest_value);
}
%%
override gst_element_link_many args
static PyObject *
_wrap_gst_element_link_many(PyObject *self, PyObject *args)
{
	PyGObject *element, *element2;
	int i, len;

	len = PyTuple_Size(args);
	if (len < 2)
	{
		PyErr_SetString(PyExc_TypeError, "gst.element_link_many requires at least two argument");
		return NULL;
	}
       

	for (i = 0; i < len; i++)
	{
		element = (PyGObject*)PyTuple_GetItem(args, i);
		if (!pygobject_check(element, &PyGstElement_Type))
		{
			PyErr_SetString(PyExc_TypeError, "argument must be a GstElement");
			return NULL;
		}
	}

	/* Mimic the real gst_element_link_many */
	element = (PyGObject*)PyTuple_GetItem(args, 0);
	element2 = (PyGObject*)PyTuple_GetItem(args, 1);

	i = 2;
	while (1) {

		if (!gst_element_link(GST_ELEMENT(element->obj),
                                      GST_ELEMENT(element2->obj)))
                {
                    PyErr_Format(PyGstExc_LinkError,
				 "failed to link %s with %s",
				 GST_ELEMENT_NAME(element->obj),
				 GST_ELEMENT_NAME(element2->obj));
                    return NULL;
                }

		if (i >= len)
			break;
		
		element = element2;
		element2 = (PyGObject*)PyTuple_GetItem(args, i);
	
		i++;
	}

	Py_INCREF(Py_True);
	return Py_True;
}


%%
override gst_element_link kwargs
static PyObject *
_wrap_gst_element_link(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "dest", "filtercaps", NULL };
    PyGObject *dest;
    PyObject *py_caps = NULL;
    int ret;
    GstCaps *caps = NULL;
    gboolean caps_is_copy;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!|O:GstElement.link",
                                     kwlist, &PyGstElement_Type, &dest, &py_caps))
        return NULL;
    if (py_caps == NULL)
      caps = NULL;
    else
      caps = pygst_caps_from_pyobject (py_caps, &caps_is_copy);
    ret = gst_element_link_filtered(GST_ELEMENT(self->obj), GST_ELEMENT(dest->obj), caps);
    if (caps && caps_is_copy)
        gst_caps_free (caps);
    if (!ret) {
	PyErr_Format(PyGstExc_LinkError,
		     "failed to link %s with %s",
		     GST_ELEMENT_NAME(self->obj),
		     GST_ELEMENT_NAME(dest->obj));
        return NULL;
    }
    return PyBool_FromLong(ret);
}

%%
override gst_element_link_filtered kwargs
static PyObject *
_wrap_gst_element_link_filtered(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "element.link_filtered is deprecated, use element.link") < 0)
	return NULL;
    return _wrap_gst_element_link (self, args, kwargs);
}

%%
override gst_element_link_pads kwargs
static gboolean
pad_name_from_object (PyObject *object, const gchar **name)
{
  if (object == Py_None) {
    *name = NULL;
    return TRUE;
  } else if (PyString_Check (object)) {
    *name = PyString_AsString (object);
    return TRUE;
  } else if (pygobject_check (object, &PyGstPad_Type)) {
    *name = gst_object_get_name (GST_OBJECT (pygobject_get (object)));
    return TRUE;
  }
  PyErr_SetString(PyExc_TypeError, "argument could not be converted to a pad");
  return FALSE;
}

static PyObject *
_wrap_gst_element_link_pads(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "srcpadname", "dest", "destpadname", NULL };
    const char *srcpadname, *destpadname;
    PyGObject *dest;
    PyObject *srcpad, *destpad;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO!O:GstElement.link_pads", kwlist,
                                     &srcpad, &PyGstElement_Type, &dest,
                                     &destpad))
        return NULL;
    if (!pad_name_from_object (srcpad, &srcpadname) ||
        !pad_name_from_object (destpad, &destpadname))
	return NULL;
    ret = gst_element_link_pads(GST_ELEMENT(self->obj), srcpadname,
                                GST_ELEMENT(dest->obj), destpadname);
    if (!ret) {
        PyErr_SetString(PyGstExc_LinkError, "link failed");
        return NULL;
    }
    return PyBool_FromLong(ret);

}

%%
override gst_element_link_pads_filtered kwargs
static PyObject *
_wrap_gst_element_link_pads_filtered(PyGObject *self, PyObject *args,
                                     PyObject *kwargs)
{
    static char *kwlist[] = { "srcpadname", "dest", "destpadname",
                              "filtercaps", NULL };
    char *srcpadname, *destpadname;
    PyGObject *dest;
    int ret;
    PyObject *py_filtercaps;
    GstCaps *filtercaps = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "sO!sO:GstElement.link_pads_filtered",
                                     kwlist, &srcpadname, &PyGstElement_Type,
                                     &dest, &destpadname, &py_filtercaps))
        return NULL;
    if (pyg_boxed_check(py_filtercaps, GST_TYPE_CAPS))
        filtercaps = pyg_boxed_get(py_filtercaps, GstCaps);
    else {
        PyErr_SetString(PyExc_TypeError, "filtercaps should be a GstCaps");
        return NULL;
    }
    ret = gst_element_link_pads_filtered(GST_ELEMENT(self->obj), srcpadname,
                                         GST_ELEMENT(dest->obj), destpadname,
                                         filtercaps);
    if (!ret) {
        PyErr_SetString(PyGstExc_LinkError, "link failed");
        return NULL;
    }
    return PyBool_FromLong(ret);
}

%%
override gst_element_unlink_many args
static PyObject *
_wrap_gst_element_unlink_many(PyObject *self, PyObject *args)
{
	PyGObject *element, *element2;
	int i, len;

	len = PyTuple_Size(args);
	if (len < 2)
	{
		PyErr_SetString(PyExc_TypeError, "gst.element_unlink_many requires at least two arguments");
		return NULL;
	}
       

	for (i = 0; i < len; i++)
	{
		element = (PyGObject*)PyTuple_GetItem(args, i);
		if (!pygobject_check(element, &PyGstElement_Type))
		{
			PyErr_SetString(PyExc_TypeError, "argument must be a GstElement");
			return NULL;
		}
	}

	/* Mimic the real gst_element_unlink_many */
	element = (PyGObject*)PyTuple_GetItem(args, 0);
	element2 = (PyGObject*)PyTuple_GetItem(args, 1);

	i = 2;
	while (1) {
		gst_element_unlink(GST_ELEMENT(element->obj), GST_ELEMENT(element2->obj));

		if (i >= len)
			break;
		
		element = element2;
		element2 = (PyGObject*)PyTuple_GetItem(args, i);
	
		i++;
	}
	Py_INCREF(Py_None);
	return Py_None;
}
%%
override gst_element_send_event kwargs
static PyObject *
_wrap_gst_element_send_event(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "event", NULL };
    PyObject *py_event;
    int ret;
    GstEvent *event = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GstElement.send_event", kwlist, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GST_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GstEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GstEvent");
        return NULL;
    }

    /* The pipeline unrefs the event, but we want to keep the ownership */
    gst_event_ref(event);
    
    ret = gst_element_send_event(GST_ELEMENT(self->obj), event);
    return PyBool_FromLong(ret);

}
%%
override gst_element_factory_get_pad_templates
static PyObject *
_wrap_gst_element_factory_get_pad_templates(PyGObject *self)
{
	const GList *pads;
	PyObject *list;
	
	pads = gst_element_factory_get_pad_templates(GST_ELEMENT_FACTORY(self->obj));

	list = PyList_New(0);
	for (; pads; pads = g_list_next (pads)) 
		PyList_Append(list, pygobject_new(pads->data));
		
	return list;
}
